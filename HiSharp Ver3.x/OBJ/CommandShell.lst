C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/22/2021 15:07:26 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE COMMANDSHELL
OBJECT MODULE PLACED IN .\OBJ\CommandShell.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE CommandShell.c COMPACT OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT
                    -(.\OBJ\CommandShell.lst) TABS(2) OBJECT(.\OBJ\CommandShell.obj)

line level    source

   1          //  **************************************************************************
   2          //
   3          //       Copyright (c) 1992-2006 Professonal Computer Technology Co., Ltd
   4          //
   5          //      All rights are reserved. Reproduction in whole or in parts is
   6          //  prohibited without the prior written consent of the copyright owner.
   7          //  --------------------------------------------------------------------------
   8          //
   9          //  Module: CommandSell.C
  10          //
  11          //  Purpose: Implementation of CommandSell.
  12          //
  13          //  Version: 0.01                                   2006/10/22 10:39¤U¤È
  14          //
  15          //  Compiler: Keil 8051 C Compiler v7.2
  16          //
  17          //  Reference:
  18          //
  19          //
  20          //
  21          //  --------------------------------------------------------------------------
  22          //  Modification:
  23          //
  24          //  R0.01 2006/10/22 10:39¤U¤È Phoenix Chuang
  25          //  Reason:
  26          //    1. Original.
  27          //  Solution:
  28          //  
  29          //  **************************************************************************
  30          //  -----------------------------------
  31          //      Header Files
  32          //  ----------------------------------- 
  33          #include "Types.h"
  34          #include "CommandShell.h"
  35          #include "UART.h"
  36          #include "Timer.h"
  37          #include "BusCtrl.h"
  38          #include "TW2835_Init.h"
  39          #include "TW28xx_Audio.h"
  40          #include "TW28xx_Video.h"
  41          #include "OSDCtrl.h"
  42          #include "OSDAction.h"
  43          #include "Main.h"
  44          
  45          
  46          // Table define on code
  47          
  48          
  49          //  ------------------------------------
  50          //      Macro Definitions
  51          //  ------------------------------------ 
  52          #define WINCH     sysdat.channel_link
  53          #define RECWINTYPE  sysdat.video_mix_type
  54          #define RECLKTP     sysdat.link_type
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/22/2021 15:07:26 PAGE 2   

  55          #define OSDREFALSH  msg.osd_falsh
  56          #define selwintype  msg.video_mix_type
  57            
  58          //  ------------------------------------
  59          //      Type Definitions
  60          //  ------------------------------------
  61          #if (TW2835_MCU == TW8806_MODEL_WINBOND)  //Pinchi 20150401 add
              #define VERSION "320"
              #else
  64            #if (defined UTC)
                #define VERSION "333"
                #elif (defined HS)
                  #ifdef HOLGER
                  #define VERSION "335" ///for Holger PAL
                  #else
                  #define VERSION "334"
                  #endif
                #else
  73            #define VERSION "332"
  74            #endif
  75          #endif
  76          
  77          #ifdef HOLGER
              #define VIDEO_SYS   'P' //NTSC
              #else
  80          #define VIDEO_SYS   'N' //NTSC
  81          #endif
  82          
  83          //  ------------------------------------
  84          //      Variables Definitions
  85          //  ------------------------------------
  86            SYS_DATA sysdat;
  87            SYS_MESSAGE msg;
  88          
  89          //  extern bit VlossFlag;//ryan@20150318
  90          
  91          //  ------------------------------------
  92          //      Function Prototypes
  93          //  ------------------------------------
  94          
  95          // ***************************************************************************
  96          
  97          // ===========================================================================
  98          //                      Parallel function description
  99          // ===========================================================================
 100          //
 101          // Get Command String from Command Buffer
 102          //
 103          U8 PCT_GetFirstStr(char **tagStr, char **sourceStr) 
 104          {
 105   1        if( **sourceStr == '\0' ) return false;
 106   1        while(**sourceStr == ' ' ) (*sourceStr)++;
 107   1        *tagStr = *sourceStr;
 108   1        (*sourceStr)++;
 109   1        while(1) {
 110   2          if( **sourceStr==' ' ) {
 111   3            **sourceStr = '\0';
 112   3            (*sourceStr)++;
 113   3            return true;
 114   3          } else if( **sourceStr == '\0' ) {
 115   3            return true;
 116   3          } else (*sourceStr)++;
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/22/2021 15:07:26 PAGE 3   

 117   2        }
 118   1      }
 119          
 120          // ===========================================================================
 121          //
 122          // String Transfer to Command Code 
 123          //
 124          U16 PCT_StrToCommCode(char *Str)
 125          {
 126   1        data U16 ret=0;
 127   1        
 128   1        while(*Str != '\0' ) ret+=*Str++;
 129   1        return ret;
 130   1      }
 131          
 132          // ===========================================================================
 133          //
 134          // Send ACK to TW8806
 135          //
 136          void PCT_SendACK(void)
 137          {
 138   1        RS_tx('A');
 139   1        RS_tx('C');
 140   1        RS_tx('K');
 141   1      }
 142          
 143          // ===========================================================================
 144          //
 145          // ===========================================================================
 146          //
 147          void PCT_CheckVMixType(U8 _typ)
 148          {
 149   1        data U8 tmplktp=0;
 150   1        
 151   1        tmplktp += (WINCH[0]&0x03); 
 152   1        tmplktp += (WINCH[1]&0x03)<<2; 
 153   1        tmplktp += (WINCH[2]&0x03)<<4; 
 154   1        tmplktp += (WINCH[3]&0x03)<<6; 
 155   1        
 156   1        if((RECWINTYPE==_typ)&&(tmplktp==RECLKTP)) {
 157   2          OSDREFALSH = OFF;
 158   2          return; 
 159   2        }
 160   1        OSDREFALSH = ON;
 161   1        RECLKTP = tmplktp;
 162   1        RECWINTYPE = _typ;
 163   1      }
 164          
 165          // ===========================================================================
 166          
 167          // ***************************************************************************
 168          // Process Command Shell Function
 169          // ***************************************************************************
 170          //
 171          // This is to communicate with PC AP 
 172          //
 173          void MoniReadPageBuffer(PCHAR szParam)
 174          {
 175   1        data U8 page, start, end;
 176   1      
 177   1        sscanf(szParam, "%bx %bx %bx", &page, &start, &end); 
 178   1      
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/22/2021 15:07:26 PAGE 4   

 179   1        do {
 180   2          printf("\n<R>%02bx[%02bx]=%02bx", page, start, TW28_ReadByte(page, start) );
 181   2          start++;
 182   2        }while(start != end);
 183   1      }
 184          
 185          // ***************************************************************************
 186          //
 187          // This is to communicate with PC AP 
 188          //
 189          void MoniReadOneBuffer(PCHAR szParam)
 190          {
 191   1        data U8 page, addr;
 192   1      
 193   1        sscanf(szParam, "%bx %bx", &page, &addr); 
 194   1      
 195   1        printf("\n<R>%02bx[%02bx]=%02bx", page, addr, TW28_ReadByte(page, addr) );
 196   1      }
 197          
 198          // ***************************************************************************
 199          //
 200          // This is to communicate with PC AP 
 201          //
 202          void MoniWriteOneBuffer(PCHAR szParam)
 203          {
 204   1        data U8 page, addr, dat;
 205   1      
 206   1        sscanf(szParam, "%bx %bx %bx", &page, &addr, &dat); 
 207   1        TW28_WriteByte(page, addr, dat);
 208   1      }
 209          
 210          // ***************************************************************************
 211          //
 212          // Monitor ASCIBUS Write Byte
 213          //
 214          void MoniWriteAsicByte(PCHAR szParam)
 215          {
 216   1        data U8 _dev=0;
 217   1        data U8 _pg=0;
 218   1        data U8 _addr=0;
 219   1        data U8 _wdat=0;
 220   1        
 221   1        sscanf(szParam, "%bx %bx %bx %bx ", &_dev, &_pg, &_addr, &_wdat);
 222   1        TW28_WriteByte(_pg, _addr, _wdat);
 223   1      }
 224          
 225          // ***************************************************************************
 226          //
 227          // Monitor ASCIBUS Write Byte
 228          //
 229          void MoniReadAsicByte(PCHAR szParam)
 230          {
 231   1        data U8 _dev=0;
 232   1        data U8 _pg=0;
 233   1        data U8 _addr=0;
 234   1        data U8 _rdat=0;
 235   1        
 236   1        sscanf(szParam, "%1bx %1bx %1bx ", &_dev, &_pg, &_addr);
 237   1        _rdat = TW28_ReadByte(_pg, _addr);
 238   1        printf("ReadAsicByte == %bx \n", _rdat);
 239   1      }
 240          
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/22/2021 15:07:26 PAGE 5   

 241          // ***************************************************************************
 242          //
 243          // Monitor Audio Mixing 
 244          // Format : amix N ch0:val ch1:val ch2:val ch3:val ch4:val 
 245          //
 246          void MoniAudioMixing(PCHAR szParam)
 247          {
 248   1        data U8 selch0,selch1,selch2,selch3,selch4; 
 249   1        data U8 valch0,valch1,valch2,valch3,valch4; 
 250   1        char *getStr;
 251   1        code U8 chaddr[] = {ADO_MIX_MUTE_AIN0, \
 252   1                  ADO_MIX_MUTE_AIN1, \
 253   1                  ADO_MIX_MUTE_AIN2, \
 254   1                  ADO_MIX_MUTE_AIN3, \
 255   1                  ADO_MIX_MUTE_PBAI \
 256   1        };  
 257   1      
 258   1        PCT_GetFirstStr(&getStr,&szParam);
 259   1      
 260   1        PCT_AudioMixMute(0, ADO_MIX_MUTE_AIN0+ \
 261   1                  ADO_MIX_MUTE_AIN1+ \
 262   1                  ADO_MIX_MUTE_AIN2+ \
 263   1                  ADO_MIX_MUTE_AIN3+ \
 264   1                  ADO_MIX_MUTE_PBAI, OFF);
 265   1      
 266   1        switch( atoi(getStr) ) {
 267   2        case 1:
 268   2          sscanf(szParam,"ch%bd:%bd ",&selch0,&valch0);
 269   2          PCT_AudioMixCtrl(0, selch0, valch0);
 270   2          PCT_AudioMixMute(0, chaddr[selch0], ON);
 271   2          break;
 272   2        
 273   2        case 2:
 274   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ", \
 275   2            &selch0, &valch0, &selch1, &valch1);
 276   2          PCT_AudioMixCtrl(0, selch0, valch0);
 277   2          PCT_AudioMixCtrl(0, selch1, valch1);
 278   2          PCT_AudioMixMute(0, chaddr[selch0]+chaddr[selch1], ON);
 279   2          break;
 280   2        
 281   2        case 3:
 282   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 283   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2);
 284   2          PCT_AudioMixCtrl(0, selch0, valch0);
 285   2          PCT_AudioMixCtrl(0, selch1, valch1);
 286   2          PCT_AudioMixCtrl(0, selch2, valch2);
 287   2          PCT_AudioMixMute(0, chaddr[selch0]+chaddr[selch1]+chaddr[selch2], ON);
 288   2          break;
 289   2        
 290   2        case 4:
 291   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 292   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2, &selch3, &valch3);
 293   2          PCT_AudioMixCtrl(0, selch0, valch0);
 294   2          PCT_AudioMixCtrl(0, selch1, valch1);
 295   2          PCT_AudioMixCtrl(0, selch2, valch2);
 296   2          PCT_AudioMixCtrl(0, selch3, valch3);
 297   2      
 298   2          PCT_AudioMixMute(0, chaddr[selch0]+chaddr[selch1]+chaddr[selch2]+chaddr[selch3], ON);
 299   2          break;
 300   2      
 301   2        case 5:
 302   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/22/2021 15:07:26 PAGE 6   

 303   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2, &selch3, &valch3,  &selch4, &valch4 );
 304   2          PCT_AudioMixCtrl(0, selch0, valch0);
 305   2          PCT_AudioMixCtrl(0, selch1, valch1);
 306   2          PCT_AudioMixCtrl(0, selch2, valch2);
 307   2          PCT_AudioMixCtrl(0, selch3, valch3);
 308   2          PCT_AudioMixCtrl(0, selch4, valch4);
 309   2      
 310   2          PCT_AudioMixMute(0, chaddr[selch0]+chaddr[selch1]+chaddr[selch2]+chaddr[selch3]+chaddr[selch4], ON);
 311   2          break;
 312   2        
 313   2        default:
 314   2          break;
 315   2        }
 316   1      }
 317          
 318          // ***************************************************************************
 319          //
 320          // Monitor Audio Mute 
 321          // Format : amute
 322          //
 323          void MoniAudioMute(void)
 324          {
 325   1        PCT_AudioMixMute(0, ADO_MIX_MUTE_AIN0+ \
 326   1                  ADO_MIX_MUTE_AIN1+ \
 327   1                  ADO_MIX_MUTE_AIN2+ \
 328   1                  ADO_MIX_MUTE_AIN3+ \
 329   1                  ADO_MIX_MUTE_PBAI, OFF);
 330   1        PCT_AudioSelLive(0, 0xFF);
 331   1      }
 332          
 333          // ***************************************************************************
 334          //
 335          // Monitor Audio Mixing 
 336          // Format : again N ch0:val ch1:val ch2:val ch3:val ch5:val
 337          //
 338          void MoniAudioGain(PCHAR szParam)
 339          {
 340   1        data U8 selch0,selch1,selch2,selch3,selch4; 
 341   1        data U8 ch0val,ch1val,ch2val,ch3val,ch4val; 
 342   1        char *getStr;
 343   1      
 344   1        PCT_GetFirstStr(&getStr,&szParam);
 345   1      
 346   1        switch( atoi(getStr) ) {
 347   2        case 1:
 348   2          sscanf(szParam,"ch%bd:%bd ",&selch0,&ch0val);
 349   2          PCT_AudioGainCtrl(0, selch0, ch0val);
 350   2          break;
 351   2        
 352   2        case 2:
 353   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ", \
 354   2            &selch0, &ch0val, &selch1, &ch1val);
 355   2          PCT_AudioGainCtrl(0, selch0, ch0val);
 356   2          PCT_AudioGainCtrl(0, selch1, ch1val);
 357   2          break;
 358   2        
 359   2        case 3:
 360   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 361   2            &selch0, &ch0val, &selch1, &ch1val, &selch2, &ch2val);
 362   2          PCT_AudioGainCtrl(0, selch0, ch0val);
 363   2          PCT_AudioGainCtrl(0, selch1, ch1val);
 364   2          PCT_AudioGainCtrl(0, selch2, ch2val);
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/22/2021 15:07:26 PAGE 7   

 365   2          break;
 366   2        
 367   2        case 4:
 368   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 369   2            &selch0, &ch0val, &selch1, &ch1val, &selch2, &ch2val, &selch3, &ch3val);
 370   2          PCT_AudioGainCtrl(0, selch0, ch0val);
 371   2          PCT_AudioGainCtrl(0, selch1, ch1val);
 372   2          PCT_AudioGainCtrl(0, selch2, ch2val);
 373   2          PCT_AudioGainCtrl(0, selch3, ch3val);
 374   2          break;
 375   2        
 376   2        case 5:
 377   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 378   2            &selch0, &ch0val, &selch1, &ch1val, &selch2, &ch2val, &selch3, &ch3val, &selch4, &ch4val);
 379   2          PCT_AudioGainCtrl(0, selch0, ch0val);
 380   2          PCT_AudioGainCtrl(0, selch1, ch1val);
 381   2          PCT_AudioGainCtrl(0, selch2, ch2val);
 382   2          PCT_AudioGainCtrl(0, selch3, ch3val);
 383   2          PCT_AudioGainCtrl(0, selch4, ch4val);
 384   2          break;
 385   2        
 386   2        default:
 387   2          break;
 388   2        }
 389   1      }
 390          
 391          // ***************************************************************************
 392          //
 393          // Monitor Select Live or Mixing Mode 
 394          // alive chan (chan=0xFF is Mixing Mode)
 395          //
 396          void MoniAudioLive(PCHAR szParam)
 397          {
 398   1        data U8 chan;
 399   1      
 400   1        sscanf(szParam, "%bd ", &chan);
 401   1      
 402   1        PCT_AudioSelLive(0,chan);
 403   1      }
 404          
 405          // ***************************************************************************
 406          //
 407          // TW2835 Register All Dump
 408          //
 409          void MoniRegisterDump(void)
 410          {
 411   1        data U8 addr,page;
 412   1        
 413   1      
 414   1        for(page=0;page<3;page++) {
 415   2          printf("\n ======== PAGE %b2x =============\n",page);
 416   2          addr = 0;
 417   2          do {
 418   3            printf("%b2x\t", TW28_ReadByte(page, addr));
 419   3            addr++;
 420   3            if((addr%16)==0)  printf("\n"); 
 421   3          } while( addr );
 422   2        }
 423   1      }
 424          
 425          // ***************************************************************************
 426          //
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/22/2021 15:07:26 PAGE 8   

 427          // video signal mixing to windows
 428          //
 429          void MoniVideoMixWin(PCHAR szParam)
 430          {
 431   1        data U8 chose,wintp;
 432   1      
 433   1        sscanf(szParam, "%1bx %1bx ch%1bx ch%1bx ch%1bx ch%1bx ",
 434   1                &chose, &wintp, &WINCH[0], &WINCH[1], &WINCH[2], &WINCH[3]);
 435   1        chose = (chose<<4)+(wintp&0x0F);
 436   1        PCT_SetXVideoMixing(chose, WINCH);  
 437   1      }
 438          
 439          // ***************************************************************************
 440          //
 441          // setting windows attribute
 442          //
 443          void MoniVideoMixAttr(PCHAR szParam)
 444          {
 445   1        data U16 chose;
 446   1        data U8 attrsel,setval;
 447   1        data U8   winNm[4],wincnt=0;
 448   1        data U8   division;
 449   1        char *getStr;
 450   1      
 451   1        PCT_GetFirstStr(&getStr,&szParam);
 452   1        division = atoi(getStr); 
 453   1      
 454   1        PCT_GetFirstStr(&getStr,&szParam);
 455   1        chose = PCT_StrToCommCode(getStr); 
 456   1      
 457   1        if( chose==PCT_StrToCommCode("enrecall") ) {
 458   2          attrsel = WIN_RECALL_EN;
 459   2          setval  = ON;
 460   2        } else if ( chose==PCT_StrToCommCode("enfreeze") ) {
 461   2          attrsel = WIN_FREEZE;
 462   2          setval  = ON;
 463   2        } else if ( chose==PCT_StrToCommCode("enhmirror") ) {
 464   2          attrsel = WIN_HMIRROR;
 465   2          setval  = ON;
 466   2        } else if ( chose==PCT_StrToCommCode("envmirror") ) {
 467   2          attrsel = WIN_VMIRROR;
 468   2          setval  = ON;
 469   2        } else if ( chose==PCT_StrToCommCode("enenhance") ) {
 470   2          attrsel = WIN_ENHANCE;
 471   2          setval  = ON;
 472   2        } else if ( chose==PCT_StrToCommCode("enblank") ) {
 473   2          attrsel = WIN_BLANK;
 474   2          setval  = ON;
 475   2        } else if ( chose==PCT_StrToCommCode("enbound") ) {
 476   2          attrsel = WIN_BOUND;
 477   2          setval  = ON;
 478   2        } else if ( chose==PCT_StrToCommCode("enblink") ) {
 479   2          attrsel = WIN_BLINK;
 480   2          setval  = ON;
 481   2        } else if ( chose==PCT_StrToCommCode("disrecall") ) {
 482   2          attrsel = WIN_RECALL_EN;
 483   2          setval  = OFF;
 484   2        } else if ( chose==PCT_StrToCommCode("disfreeze") ) {
 485   2          attrsel = WIN_FREEZE;
 486   2          setval  = OFF;
 487   2        } else if ( chose==PCT_StrToCommCode("dishmirror") ) {
 488   2          attrsel = WIN_HMIRROR;
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/22/2021 15:07:26 PAGE 9   

 489   2          setval  = OFF;
 490   2        } else if ( chose==PCT_StrToCommCode("disvmirror") ) {
 491   2          attrsel = WIN_VMIRROR;
 492   2          setval  = OFF;
 493   2        } else if ( chose==PCT_StrToCommCode("disenhance") ) {
 494   2          attrsel = WIN_ENHANCE;
 495   2          setval  = OFF;
 496   2        } else if ( chose==PCT_StrToCommCode("disblank") ) {
 497   2          attrsel = WIN_BLANK;
 498   2          setval  = OFF;
 499   2        } else if ( chose==PCT_StrToCommCode("disbound") ) {
 500   2          attrsel = WIN_BOUND;
 501   2          setval  = OFF;
 502   2        } else if ( chose==PCT_StrToCommCode("disblink") ) {
 503   2          attrsel = WIN_BLINK;
 504   2          setval  = OFF;
 505   2        } else {
 506   2          return;
 507   2        }
 508   1      
 509   1        while( PCT_GetFirstStr(&getStr,&szParam) ) {
 510   2          if(*getStr=='w' && *(getStr+1)=='i' && *(getStr+2)=='n') 
 511   2          {
 512   3            winNm[wincnt] = atoi(getStr+3);
 513   3            wincnt++;
 514   3          }
 515   2        }
 516   1        for( ; wincnt!=0; wincnt--) {
 517   2          if( winNm[wincnt-1]<division ) {
 518   3            PCT_WinAttrCtrl(winNm[wincnt-1], attrsel, setval);
 519   3          }
 520   2        }
 521   1      }
 522          
 523          // ***************************************************************************
 524          //
 525          // Monitor Video Y Channel Select Live or Mixing Mode 
 526          // yvmix chan (chan=0x04 is Mixing Mode)
 527          //
 528          void MoniYVideoMix(PCHAR szParam)
 529          {
 530   1        data U8 chan;
 531   1      
 532   1        sscanf(szParam, "%bd ", &chan);
 533   1        PCT_SetYVideoMixing(chan);
 534   1      }
 535          
 536          // ***************************************************************************
 537          //
 538          // Monitor Video Auto Detect Format 
 539          //
 540          void MoniVideoAutoDetect(void)
 541          {
 542   1        printf("===== Format : ch0=[%bx] ch1=[%bx] ch2=[%bx] ch3=[%bx] =====\n",  \ 
 543   1            PCT_DetectVideoFormat(0x00), \
 544   1            PCT_DetectVideoFormat(0x01), \
 545   1            PCT_DetectVideoFormat(0x02), \
 546   1            PCT_DetectVideoFormat(0x03) \
 547   1        );
 548   1      }
 549          
 550          // ***************************************************************************
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/22/2021 15:07:26 PAGE 10  

 551          //
 552          // Monitor Setting Video Format 
 553          //
 554          void MoniSetVideoFormat(PCHAR szParam)
 555          {
 556   1        data U8 selch0,selch1,selch2,selch3;  
 557   1        data U8 valch0,valch1,valch2,valch3;  
 558   1        char *getStr;
 559   1      
 560   1        PCT_GetFirstStr(&getStr,&szParam);
 561   1      
 562   1        switch( atoi(getStr) ) {
 563   2        case 1:
 564   2          sscanf(szParam,"ch%bd:%bd ",&selch0,&valch0);
 565   2          PCT_SetVideoFormat(0, selch0, valch0<<4);
 566   2          break;
 567   2        
 568   2        case 2:
 569   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ", \
 570   2            &selch0, &valch0, &selch1, &valch1);
 571   2          PCT_SetVideoFormat(0, selch0, valch0<<4);
 572   2          PCT_SetVideoFormat(0, selch1, valch1<<4);
 573   2          break;
 574   2        
 575   2        case 3:
 576   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 577   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2);
 578   2          PCT_SetVideoFormat(0, selch0, valch0<<4);
 579   2          PCT_SetVideoFormat(0, selch1, valch1<<4);
 580   2          PCT_SetVideoFormat(0, selch2, valch2<<4);
 581   2          break;
 582   2        
 583   2        case 4:
 584   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 585   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2, &selch3, &valch3);
 586   2          PCT_SetVideoFormat(0, selch0, valch0<<4);
 587   2          PCT_SetVideoFormat(0, selch1, valch1<<4);
 588   2          PCT_SetVideoFormat(0, selch2, valch2<<4);
 589   2          PCT_SetVideoFormat(0, selch3, valch3<<4);
 590   2          break;
 591   2      
 592   2        default:
 593   2          break;
 594   2        }
 595   1      }
 596          
 597          // ***************************************************************************
 598          //
 599          // Monitor Setting Video Format 
 600          //
 601          void MoniShowSODStr(PCHAR szParam)
 602          {
 603   1        data U8 addrx,addry;
 604   1        char *getStr;
 605   1        
 606   1        PCT_GetFirstStr(&getStr,&szParam);
 607   1        addrx=atoi(getStr);
 608   1        PCT_GetFirstStr(&getStr,&szParam);
 609   1        addry=atoi(getStr);
 610   1      
 611   1        PCT_PreSetForegroundColor(OSD_COL_100WHT);
 612   1        PCT_PreSetBackgroundColor(OSD_COL_BLU);
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/22/2021 15:07:26 PAGE 11  

 613   1        PCT_SetOSDDrawPage(WRPHX_PAGE5);
 614   1        PCT_ShowOSDString(PTH_X, addrx, addry, szParam);
 615   1        PCT_EnShowOSDPage(WRPHX_PAGE5);
 616   1      }
 617          
 618          // ***************************************************************************
 619          //
 620          // Audio Control for HiSarp
 621          //
 622          void PCT_AudioActionForHS(void)
 623          {
 624   1        data U8 winid;
 625   1        data U8 muteFlage=true;
 626   1      
 627   1        // ------------- Control Audio ------------
 628   1        for(winid=0; winid<4; winid++) {
 629   2          if(SYSWINATTR[winid]&BIT4) {
 630   3            PCT_AudioSelLive(0,WINCH[winid]);
 631   3            muteFlage = false;
 632   3          }
 633   2        }
 634   1      
 635   1        if(muteFlage) {
 636   2          // Audio Mute
 637   2          PCT_AudioMixMute(0, ADO_MIX_MUTE_AIN0+ \
 638   2                    ADO_MIX_MUTE_AIN1+ \
 639   2                    ADO_MIX_MUTE_AIN2+ \
 640   2                    ADO_MIX_MUTE_AIN3+ \
 641   2                    ADO_MIX_MUTE_PBAI, OFF);
 642   2          PCT_AudioSelLive(0, 0xFF);
 643   2        }
 644   1        // ----------------------------------------
 645   1      }
 646          
 647          // ***************************************************************************
 648          //
 649          // Command Shell for HiSarp
 650          //
 651          BYTE xdata Original_selwintype = 0;//Kane @HS 2007 0724 Ver3.4
 652          void MoniHSComm(PCHAR szParam) {
 653   1        data U8 winid;
 654   1        data U8 chose,wintp;
 655   1        
 656   1        sscanf(szParam, "%bx %bx ch%bx:%bx ch%bx:%bx ch%bx:%bx ch%bx:%bx ",
 657   1                &chose, &wintp, &WINCH[0], &SYSWINATTR[0], &WINCH[1], &SYSWINATTR[1], &WINCH[2], &SYSWINATTR[2], &WIN
             -CH[3], &SYSWINATTR[3]);
 658   1      
 659   1        selwintype = (SYSTYPE<<7)+(chose<<4)+(wintp&0x0F);
 660   1      
 661   1        // ----------- Y Chanle setting windows horizontal mirror ----------
 662   1          
 663   1        SYSCHATTR[WINCH[0]]=SYSWINATTR[0];
 664   1        SYSCHATTR[WINCH[1]]=SYSWINATTR[1];
 665   1        SYSCHATTR[WINCH[2]]=SYSWINATTR[2];
 666   1        SYSCHATTR[WINCH[3]]=SYSWINATTR[3];
 667   1      
 668   1        PCT_WinAttrCtrlY(0, WIN_HMIRROR, SYSCHATTR[0]&BIT0);  
 669   1        PCT_WinAttrCtrlY(1, WIN_HMIRROR, SYSCHATTR[1]&BIT0);  
 670   1        PCT_WinAttrCtrlY(2, WIN_HMIRROR, SYSCHATTR[2]&BIT0);  
 671   1        PCT_WinAttrCtrlY(3, WIN_HMIRROR, SYSCHATTR[3]&BIT0);  
 672   1        // -----------------------------------------------------------------
 673   1      
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/22/2021 15:07:26 PAGE 12  

 674   1        // ------------- Control Video ------------
 675   1        //if(Original_selwintype != selwintype)//Kane @HS 2007 0724 Ver3.4
 676   1        PCT_RecompenseYHdelay(SYSCHATTR);
 677   1        PCT_SetVideoHDelay(selwintype, WINCH, SYSWINATTR);
 678   1        
 679   1        PCT_SetXVideoMixing(selwintype, WINCH);
 680   1        //PCT_VideoLastModify();
 681   1        for(winid=0; winid<4; winid++) 
 682   1          PCT_WinAttrCtrl(winid, WIN_HMIRROR, SYSWINATTR[winid]&BIT0);
 683   1        // ----------------------------------------
 684   1      
 685   1        // ------------- Control OSD ------------
 686   1        DisUserTimer(USERTMID0);    // Disable real-time detect VLoss
 687   1        EnUserTimer(USERTMID1,5);   // Enable OSD Delay Timer
 688   1        PCT_FlashOSDCtrl(ON);
 689   1        PCT_CheckVMixType(selwintype);
 690   1        PCT_DisShowOSDPage(DISOSD_PHX);
 691   1        PCT_ClearOSDPageX(WRPHX_PAGE0);
 692   1        PCT_ShowModeIcon();
 693   1        PCT_OSD_ActionPthX(SYSWINATTR);
 694   1        Original_selwintype = selwintype;//Kane @HS 2007 0724 Ver3.4
 695   1        // --------------------------------------
 696   1      }
 697          
 698          // ***************************************************************************
 699          //
 700          // Real Time Check System Type PAL or NTSC
 701          //
 702          bit PCT_CheckSystem(void)
 703          {
 704   1        //Kane add>>>>
 705   1        char TempSystem;
 706   1        TempSystem = PCT_DetectVideoFormat(SENSORCHANNEL);
 707   1        //if(SYSTYPE == PCT_DetectVideoFormat(SENSORCHANNEL)) return true;//Kane canceled
 708   1        if(TempSystem == NONE_SYSTEM)
 709   1          return FALSE;
 710   1        if(TempSystem == SYSTYPE)
 711   1          return TRUE;
 712   1      
 713   1        SYSTYPE = TempSystem;
 714   1        //Kane Add<<<<
 715   1        //SYSTYPE = PCT_DetectVideoFormat(SENSORCHANNEL);//Kane canceled
 716   1        SYSMIXTYP = (SYSTYPE<<7)|(SYSMIXTYP&0x7F);
 717   1      
 718   1        PCT_EnShowOSDPage(WRPHX_PAGE1);
 719   1        // ------------- Control Video ------------
 720   1        PCT_ChangeSystemType(SYSTYPE);
 721   1        PCT_RecompenseYHdelay(SYSCHATTR); // preset Y Recompense
 722   1        PCT_SetVideoHDelay(RECWINTYPE, WINCH, SYSWINATTR);
 723   1        
 724   1        PCT_SetXVideoMixing(RECWINTYPE, WINCH);
 725   1        //PCT_VideoLastModify();
 726   1        // ------------- Control OSD ------------
 727   1        PCT_ClearOSDPageX(WRPHX_PAGE0);
 728   1        PCT_ShowModeIcon();
 729   1        PCT_OSD_ActionPthX(SYSWINATTR);
 730   1        PCT_OSDActionForHS();
 731   1        // --------------------------------------
 732   1        return TRUE;  //Pinchi 20150323 add for compiler warning
 733   1      }
 734          
 735          // ***************************************************************************
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/22/2021 15:07:26 PAGE 13  

 736          //
 737          // Command Shell for HiSarp Setting S or J Mode
 738          //
 739          void MoniHSCommSJmode(PCHAR szParam)
 740          {
 741   1        sscanf(szParam, "%bd ", &SYSMODE);
 742   1      }
 743          
 744          // ***************************************************************************
 745          //
 746          // Command Shell for HiSarp Setting S or J Mode
 747          //
 748          void MoniHSCommDisScroll(void)
 749          {
 750   1        PCT_EnShowOSDPage(WRPHX_PAGE1);
 751   1      }
 752          
 753          // ***************************************************************************
 754          //
 755          // Command Shell for HiSarp Setting S or J Mode
 756          //
 757          #if 1  //Pinchi 20150415 add
 758          void MoniHSCommVersion(void)
 759          {
 760   1        U8 version=0;
 761   1      
 762   1      #if (TW2835_MCU == TW8816_MODEL_MEGAWIN)  //Pinchi 20150415 add
 763   1        RS_tx('M');
 764   1      #else
                RS_tx('W');
              #endif
 767   1        //RS_tx(VERSION[0]-'0');
 768   1        //version = (VERSION[1]-'0')*10 + (VERSION[2]-'0');
 769   1        //RS_tx(version);
 770   1        RS_tx(VERSION[0]);
 771   1        RS_tx(VERSION[1]);
 772   1        RS_tx(VERSION[2]);
 773   1        RS_tx(VIDEO_SYS);//ryan@20180417
 774   1        
 775   1      }
 776          #else
              void MoniHSCommVersion(void)
              {
                RS_tx(VERSION[0]);
                RS_tx(VERSION[1]);
              }
              #endif
 783          
 784          // ***************************************************************************
 785          //
 786          // Runing Command Shell
 787          //
 788          
 789          U8 PCT_RunCommShell(char *strptr)
 790          {
 791   1        data U16 commcode;
 792   1        char *getStr;
 793   1          
 794   1        // ---------- Run Command Shell Entry ----------
 795   1        //Kane @HS 2007 0809 Ver3.5>>>>
 796   1        PCT_GetFirstStr(&getStr, &strptr);
 797   1        //getStr=strptr+4;
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/22/2021 15:07:26 PAGE 14  

 798   1        //Kane @HS 2007 0809 Ver3.5<<<<
 799   1        commcode = PCT_StrToCommCode(getStr); 
 800   1        
 801   1        if (commcode == PCT_StrToCommCode("&")) {
 802   2          //printf("Read Page Buffer Data");
 803   2          MoniReadPageBuffer(strptr);
 804   2        }else if( commcode == PCT_StrToCommCode("(")) {
 805   2          //printf("Read One Buffer Data");
 806   2          MoniReadOneBuffer(strptr);
 807   2        }else if( commcode == PCT_StrToCommCode(")")) {
 808   2          //printf("Write One Buffer Data");
 809   2          MoniWriteOneBuffer(strptr);
 810   2        }else if( commcode == PCT_StrToCommCode("busw")) {
 811   2          // ===== ASICBUS Write Byte ======
 812   2          //printf("Command is Write Bus");
 813   2          MoniWriteAsicByte(strptr);
 814   2        } else if (commcode == PCT_StrToCommCode("busr")) {
 815   2          // ===== ASICBUS Read Byte =======
 816   2          //printf("Command is Read Bus");
 817   2          MoniReadAsicByte(strptr);
 818   2        } else if (commcode == PCT_StrToCommCode("amix")) {
 819   2          // ===== Audio mix =======
 820   2          //printf("Command is Audio Mixing");
 821   2          MoniAudioMixing(strptr);
 822   2        } else if (commcode == PCT_StrToCommCode("amute")) {
 823   2          // ===== Audio Mute =======
 824   2          //printf("Command is Audio Mute");
 825   2          MoniAudioMute();
 826   2        } else if (commcode == PCT_StrToCommCode("adump")) {
 827   2          // ===== List Audio Register Value =======
 828   2          //printf("List Audio Register Value");
 829   2          PCT_AudioRegList();
 830   2        } else if (commcode == PCT_StrToCommCode("again")) {
 831   2          // ===== Audio Gain Control =======
 832   2          //printf("Audio Gain Control");
 833   2          MoniAudioGain(strptr);
 834   2        } else if (commcode == PCT_StrToCommCode("alive")) {
 835   2          // ===== Audio Select Live & Mixing Mode =======
 836   2          //printf("Audio Select Live & Mixing Mode");
 837   2          MoniAudioLive(strptr);
 838   2        } else if (commcode == PCT_StrToCommCode("busrt")) {
 839   2          // ===== All Register Dump =======
 840   2          //printf("All Register Dump");
 841   2          MoniRegisterDump();
 842   2        } else if (commcode == PCT_StrToCommCode("vmix")) {
 843   2          // ===== Video Mix's Windows Type Select =======
 844   2          //printf("Video Mix's Windows Type Select");
 845   2          PCT_WinAttrClear(WIN_FREEZE);
 846   2          MoniVideoMixWin(strptr);
 847   2          PCT_SendACK();
 848   2        } else if (commcode == PCT_StrToCommCode("vmixerr")) {
 849   2          // ===== Video Mix's Windows Type Select =======
 850   2          //printf("Video Mixerr's Windows Type Select");
 851   2          MoniVideoMixWin(strptr); 
 852   2        } else if (commcode == PCT_StrToCommCode("vattr")) {
 853   2          // ===== Video Mixing Control =======
 854   2          //printf("Video Attribute Control");
 855   2          MoniVideoMixAttr(strptr);
 856   2        } else if (commcode == PCT_StrToCommCode("yvmix")) {    // HiSharp has used
 857   2          // ===== Video Mixing Control =======
 858   2          PCT_SendACK();
 859   2          //printf("Video Attribute Control");
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/22/2021 15:07:26 PAGE 15  

 860   2          MoniYVideoMix(strptr);
 861   2        } else if (commcode == PCT_StrToCommCode("init")) {
 862   2          // ===== TW2835 initial =======
 863   2          //printf("Initial TW2835");
 864   2          PCT_InitialTW2835();
 865   2        } else if (commcode == PCT_StrToCommCode("vdet")) {
 866   2          // ===== Video Mixing Control =======
 867   2          //printf("Auto Detectation Video Format");
 868   2          MoniVideoAutoDetect();
 869   2        } else if (commcode == PCT_StrToCommCode("vsetf")) {
 870   2          // ===== Video Mixing Control =======
 871   2          //printf("Setting Video Format Control");
 872   2          MoniSetVideoFormat(strptr);
 873   2        } else if (commcode == PCT_StrToCommCode("sstr")) {
 874   2          // ===== Show String on OSD =======
 875   2          //printf("Show String on OSD");
 876   2          MoniShowSODStr(strptr);
 877   2      // --------------------------------------------------------------------------------
 878   2        } else if (commcode == PCT_StrToCommCode("hscom")) {    // HiSharp has used
 879   2          PCT_SendACK();
 880   2          //printf("Command Shell for HiSharp");
 881   2          MoniHSComm(strptr);
 882   2      
 883   2          PCT_AudioActionForHS();
 884   2          PCT_OSDActionForHS();
 885   2          PCT_FlashOSDCtrl(OFF);
 886   2          
 887   2        //  VlossFlag = 0;  //ryan@20150318
 888   2        #ifdef AWT_NO_SIGNAL_MSG  //Pinchi 20150326 add
 889   2          DisUserTimer(USERTMID1);
 890   2          EnUserTimer(USERTMID0,5); 
 891   2      
 892   2        #endif
 893   2        } else if (commcode == PCT_StrToCommCode("mode")) {     // HiSharp has used
 894   2          PCT_SendACK();
 895   2          //printf("Command Shell for HiSharp Set S or J Mode");
 896   2          MoniHSCommSJmode(strptr);
 897   2        } else if (commcode == PCT_StrToCommCode("disscroll")) {  // HiSharp has used
 898   2          PCT_SendACK();
 899   2          //printf("Command Shell for HiSharp Disable Scroll!");
 900   2          MoniHSCommDisScroll();
 901   2        } else if (commcode == PCT_StrToCommCode("ver")) {  // HiSharp has used
 902   2          PCT_SendACK();
 903   2          //printf("Command Shell for HiSharp Disable Scroll!");
 904   2          MoniHSCommVersion();
 905   2          //PCT_InitialTW2835();//Kane @HS 2007 0723 Ver3.4
 906   2      // --------------------------------------------------------------------------------
 907   2        } else {
 908   2        }
 909   1      
 910   1        // ---------------------------------------------
 911   1        return true;
 912   1      }
 913          
 914          
 915          // ===========================================================================
 916          // END of File 
 917          // ===========================================================================
 918          
 919          
 920          

C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/22/2021 15:07:26 PAGE 16  


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4184    ----
   CONSTANT SIZE    =    735    ----
   XDATA SIZE       =      1    ----
   PDATA SIZE       =     25      46
   DATA SIZE        =   ----      72
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
