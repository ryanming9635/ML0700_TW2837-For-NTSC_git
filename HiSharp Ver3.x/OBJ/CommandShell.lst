C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/13/2021 11:06:05 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE COMMANDSHELL
OBJECT MODULE PLACED IN .\OBJ\CommandShell.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE CommandShell.c COMPACT OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT
                    -(.\OBJ\CommandShell.lst) TABS(2) OBJECT(.\OBJ\CommandShell.obj)

line level    source

   1          //  **************************************************************************
   2          //
   3          //       Copyright (c) 1992-2006 Professonal Computer Technology Co., Ltd
   4          //
   5          //      All rights are reserved. Reproduction in whole or in parts is
   6          //  prohibited without the prior written consent of the copyright owner.
   7          //  --------------------------------------------------------------------------
   8          //
   9          //  Module: CommandSell.C
  10          //
  11          //  Purpose: Implementation of CommandSell.
  12          //
  13          //  Version: 0.01                                   2006/10/22 10:39¤U¤È
  14          //
  15          //  Compiler: Keil 8051 C Compiler v7.2
  16          //
  17          //  Reference:
  18          //
  19          //
  20          //
  21          //  --------------------------------------------------------------------------
  22          //  Modification:
  23          //
  24          //  R0.01 2006/10/22 10:39¤U¤È Phoenix Chuang
  25          //  Reason:
  26          //    1. Original.
  27          //  Solution:
  28          //  
  29          //  **************************************************************************
  30          //  -----------------------------------
  31          //      Header Files
  32          //  ----------------------------------- 
  33          #include "Types.h"
  34          #include "CommandShell.h"
  35          #include "UART.h"
  36          #include "Timer.h"
  37          #include "BusCtrl.h"
  38          #include "TW2835_Init.h"
  39          #include "TW28xx_Audio.h"
  40          #include "TW28xx_Video.h"
  41          #include "OSDCtrl.h"
  42          #include "OSDAction.h"
  43          #include "Main.h"
  44          
  45          
  46          // Table define on code
  47          
  48          
  49          //  ------------------------------------
  50          //      Macro Definitions
  51          //  ------------------------------------ 
  52          #define WINCH     sysdat.channel_link
  53          #define RECWINTYPE  sysdat.video_mix_type
  54          #define RECLKTP     sysdat.link_type
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/13/2021 11:06:05 PAGE 2   

  55          #define OSDREFALSH  msg.osd_falsh
  56          #define selwintype  msg.video_mix_type
  57            
  58          //  ------------------------------------
  59          //      Type Definitions
  60          //  ------------------------------------
  61          #if (TW2835_MCU == TW8806_MODEL_WINBOND)  //Pinchi 20150401 add
              #define VERSION "320"
              #else
  64            #if (defined UTC)
                #define VERSION "333"
                #elif (defined HS)
                  #ifdef HOLGER
                  #define VERSION "335" ///for Holger PAL
                  #else
                  #define VERSION "334"
                  #endif
                #else
  73            #define VERSION "337"
  74            #endif
  75          #endif
  76          
  77          #ifdef HOLGER
              #define VIDEO_SYS   'P' //NTSC
              #else
  80          #define VIDEO_SYS   'N' //NTSC
  81          #endif
  82          
  83          //  ------------------------------------
  84          //      Variables Definitions
  85          //  ------------------------------------
  86            SYS_DATA sysdat;
  87            SYS_MESSAGE msg;  
  88          
  89            extern BYTE TW2837IDCheck;
  90          
  91          //  extern bit VlossFlag;//ryan@20150318
  92          
  93          //  ------------------------------------
  94          //      Function Prototypes
  95          //  ------------------------------------
  96          
  97          // ***************************************************************************
  98          
  99          // ===========================================================================
 100          //                      Parallel function description
 101          // ===========================================================================
 102          //
 103          // Get Command String from Command Buffer
 104          //
 105          U8 PCT_GetFirstStr(char **tagStr, char **sourceStr) 
 106          {
 107   1        if( **sourceStr == '\0' ) return false;
 108   1        while(**sourceStr == ' ' ) (*sourceStr)++;
 109   1        *tagStr = *sourceStr;
 110   1        (*sourceStr)++;
 111   1        while(1) {
 112   2          if( **sourceStr==' ' ) {
 113   3            **sourceStr = '\0';
 114   3            (*sourceStr)++;
 115   3            return true;
 116   3          } else if( **sourceStr == '\0' ) {
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/13/2021 11:06:05 PAGE 3   

 117   3            return true;
 118   3          } else (*sourceStr)++;
 119   2        }
 120   1      }
 121          
 122          // ===========================================================================
 123          //
 124          // String Transfer to Command Code 
 125          //
 126          U16 PCT_StrToCommCode(char *Str)
 127          {
 128   1        data U16 ret=0;
 129   1        
 130   1        while(*Str != '\0' ) ret+=*Str++;
 131   1        return ret;
 132   1      }
 133          
 134          // ===========================================================================
 135          //
 136          // Send ACK to TW8806
 137          //
 138          void PCT_SendACK(void)
 139          {
 140   1        RS_tx('A');
 141   1        RS_tx('C');
 142   1        RS_tx('K');
 143   1      }
 144          
 145          // ===========================================================================
 146          //
 147          // ===========================================================================
 148          //
 149          void PCT_CheckVMixType(U8 _typ)
 150          {
 151   1        data U8 tmplktp=0;
 152   1        
 153   1        tmplktp += (WINCH[0]&0x03); 
 154   1        tmplktp += (WINCH[1]&0x03)<<2; 
 155   1        tmplktp += (WINCH[2]&0x03)<<4; 
 156   1        tmplktp += (WINCH[3]&0x03)<<6; 
 157   1        
 158   1        if((RECWINTYPE==_typ)&&(tmplktp==RECLKTP)) {
 159   2          OSDREFALSH = OFF;
 160   2          return; 
 161   2        }
 162   1        OSDREFALSH = ON;
 163   1        RECLKTP = tmplktp;
 164   1        RECWINTYPE = _typ;
 165   1      }
 166          
 167          // ===========================================================================
 168          
 169          // ***************************************************************************
 170          // Process Command Shell Function
 171          // ***************************************************************************
 172          //
 173          // This is to communicate with PC AP 
 174          //
 175          void MoniReadPageBuffer(PCHAR szParam)
 176          {
 177   1        data U8 page, start, end;
 178   1      
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/13/2021 11:06:05 PAGE 4   

 179   1        sscanf(szParam, "%bx %bx %bx", &page, &start, &end); 
 180   1      
 181   1        do {
 182   2          printf("\n<R>%02bx[%02bx]=%02bx", page, start, TW28_ReadByte(page, start) );
 183   2          start++;
 184   2        }while(start != end);
 185   1      }
 186          
 187          // ***************************************************************************
 188          //
 189          // This is to communicate with PC AP 
 190          //
 191          void MoniReadOneBuffer(PCHAR szParam)
 192          {
 193   1        data U8 page, addr;
 194   1      
 195   1        sscanf(szParam, "%bx %bx", &page, &addr); 
 196   1      
 197   1        printf("\n<R>%02bx[%02bx]=%02bx", page, addr, TW28_ReadByte(page, addr) );
 198   1      }
 199          
 200          // ***************************************************************************
 201          //
 202          // This is to communicate with PC AP 
 203          //
 204          void MoniWriteOneBuffer(PCHAR szParam)
 205          {
 206   1        data U8 page, addr, dat;
 207   1      
 208   1        sscanf(szParam, "%bx %bx %bx", &page, &addr, &dat); 
 209   1        TW28_WriteByte(page, addr, dat);
 210   1      }
 211          
 212          // ***************************************************************************
 213          //
 214          // Monitor ASCIBUS Write Byte
 215          //
 216          void MoniWriteAsicByte(PCHAR szParam)
 217          {
 218   1        data U8 _dev=0;
 219   1        data U8 _pg=0;
 220   1        data U8 _addr=0;
 221   1        data U8 _wdat=0;
 222   1        
 223   1        sscanf(szParam, "%bx %bx %bx %bx ", &_dev, &_pg, &_addr, &_wdat);
 224   1        TW28_WriteByte(_pg, _addr, _wdat);
 225   1      }
 226          
 227          // ***************************************************************************
 228          //
 229          // Monitor ASCIBUS Write Byte
 230          //
 231          void MoniReadAsicByte(PCHAR szParam)
 232          {
 233   1        data U8 _dev=0;
 234   1        data U8 _pg=0;
 235   1        data U8 _addr=0;
 236   1        data U8 _rdat=0;
 237   1        
 238   1        sscanf(szParam, "%1bx %1bx %1bx ", &_dev, &_pg, &_addr);
 239   1        _rdat = TW28_ReadByte(_pg, _addr);
 240   1        printf("ReadAsicByte == %bx \n", _rdat);
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/13/2021 11:06:05 PAGE 5   

 241   1      }
 242          
 243          // ***************************************************************************
 244          //
 245          // Monitor Audio Mixing 
 246          // Format : amix N ch0:val ch1:val ch2:val ch3:val ch4:val 
 247          //
 248          void MoniAudioMixing(PCHAR szParam)
 249          {
 250   1        data U8 selch0,selch1,selch2,selch3,selch4; 
 251   1        data U8 valch0,valch1,valch2,valch3,valch4; 
 252   1        char *getStr;
 253   1        code U8 chaddr[] = {ADO_MIX_MUTE_AIN0, \
 254   1                  ADO_MIX_MUTE_AIN1, \
 255   1                  ADO_MIX_MUTE_AIN2, \
 256   1                  ADO_MIX_MUTE_AIN3, \
 257   1                  ADO_MIX_MUTE_PBAI \
 258   1        };  
 259   1      
 260   1        PCT_GetFirstStr(&getStr,&szParam);
 261   1      
 262   1        PCT_AudioMixMute(0, ADO_MIX_MUTE_AIN0+ \
 263   1                  ADO_MIX_MUTE_AIN1+ \
 264   1                  ADO_MIX_MUTE_AIN2+ \
 265   1                  ADO_MIX_MUTE_AIN3+ \
 266   1                  ADO_MIX_MUTE_PBAI, OFF);
 267   1      
 268   1        switch( atoi(getStr) ) {
 269   2        case 1:
 270   2          sscanf(szParam,"ch%bd:%bd ",&selch0,&valch0);
 271   2          PCT_AudioMixCtrl(0, selch0, valch0);
 272   2          PCT_AudioMixMute(0, chaddr[selch0], ON);
 273   2          break;
 274   2        
 275   2        case 2:
 276   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ", \
 277   2            &selch0, &valch0, &selch1, &valch1);
 278   2          PCT_AudioMixCtrl(0, selch0, valch0);
 279   2          PCT_AudioMixCtrl(0, selch1, valch1);
 280   2          PCT_AudioMixMute(0, chaddr[selch0]+chaddr[selch1], ON);
 281   2          break;
 282   2        
 283   2        case 3:
 284   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 285   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2);
 286   2          PCT_AudioMixCtrl(0, selch0, valch0);
 287   2          PCT_AudioMixCtrl(0, selch1, valch1);
 288   2          PCT_AudioMixCtrl(0, selch2, valch2);
 289   2          PCT_AudioMixMute(0, chaddr[selch0]+chaddr[selch1]+chaddr[selch2], ON);
 290   2          break;
 291   2        
 292   2        case 4:
 293   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 294   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2, &selch3, &valch3);
 295   2          PCT_AudioMixCtrl(0, selch0, valch0);
 296   2          PCT_AudioMixCtrl(0, selch1, valch1);
 297   2          PCT_AudioMixCtrl(0, selch2, valch2);
 298   2          PCT_AudioMixCtrl(0, selch3, valch3);
 299   2      
 300   2          PCT_AudioMixMute(0, chaddr[selch0]+chaddr[selch1]+chaddr[selch2]+chaddr[selch3], ON);
 301   2          break;
 302   2      
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/13/2021 11:06:05 PAGE 6   

 303   2        case 5:
 304   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 305   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2, &selch3, &valch3,  &selch4, &valch4 );
 306   2          PCT_AudioMixCtrl(0, selch0, valch0);
 307   2          PCT_AudioMixCtrl(0, selch1, valch1);
 308   2          PCT_AudioMixCtrl(0, selch2, valch2);
 309   2          PCT_AudioMixCtrl(0, selch3, valch3);
 310   2          PCT_AudioMixCtrl(0, selch4, valch4);
 311   2      
 312   2          PCT_AudioMixMute(0, chaddr[selch0]+chaddr[selch1]+chaddr[selch2]+chaddr[selch3]+chaddr[selch4], ON);
 313   2          break;
 314   2        
 315   2        default:
 316   2          break;
 317   2        }
 318   1      }
 319          
 320          // ***************************************************************************
 321          //
 322          // Monitor Audio Mute 
 323          // Format : amute
 324          //
 325          void MoniAudioMute(void)
 326          {
 327   1        PCT_AudioMixMute(0, ADO_MIX_MUTE_AIN0+ \
 328   1                  ADO_MIX_MUTE_AIN1+ \
 329   1                  ADO_MIX_MUTE_AIN2+ \
 330   1                  ADO_MIX_MUTE_AIN3+ \
 331   1                  ADO_MIX_MUTE_PBAI, OFF);
 332   1        PCT_AudioSelLive(0, 0xFF);
 333   1      }
 334          
 335          // ***************************************************************************
 336          //
 337          // Monitor Audio Mixing 
 338          // Format : again N ch0:val ch1:val ch2:val ch3:val ch5:val
 339          //
 340          void MoniAudioGain(PCHAR szParam)
 341          {
 342   1        data U8 selch0,selch1,selch2,selch3,selch4; 
 343   1        data U8 ch0val,ch1val,ch2val,ch3val,ch4val; 
 344   1        char *getStr;
 345   1      
 346   1        PCT_GetFirstStr(&getStr,&szParam);
 347   1      
 348   1        switch( atoi(getStr) ) {
 349   2        case 1:
 350   2          sscanf(szParam,"ch%bd:%bd ",&selch0,&ch0val);
 351   2          PCT_AudioGainCtrl(0, selch0, ch0val);
 352   2          break;
 353   2        
 354   2        case 2:
 355   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ", \
 356   2            &selch0, &ch0val, &selch1, &ch1val);
 357   2          PCT_AudioGainCtrl(0, selch0, ch0val);
 358   2          PCT_AudioGainCtrl(0, selch1, ch1val);
 359   2          break;
 360   2        
 361   2        case 3:
 362   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 363   2            &selch0, &ch0val, &selch1, &ch1val, &selch2, &ch2val);
 364   2          PCT_AudioGainCtrl(0, selch0, ch0val);
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/13/2021 11:06:05 PAGE 7   

 365   2          PCT_AudioGainCtrl(0, selch1, ch1val);
 366   2          PCT_AudioGainCtrl(0, selch2, ch2val);
 367   2          break;
 368   2        
 369   2        case 4:
 370   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 371   2            &selch0, &ch0val, &selch1, &ch1val, &selch2, &ch2val, &selch3, &ch3val);
 372   2          PCT_AudioGainCtrl(0, selch0, ch0val);
 373   2          PCT_AudioGainCtrl(0, selch1, ch1val);
 374   2          PCT_AudioGainCtrl(0, selch2, ch2val);
 375   2          PCT_AudioGainCtrl(0, selch3, ch3val);
 376   2          break;
 377   2        
 378   2        case 5:
 379   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 380   2            &selch0, &ch0val, &selch1, &ch1val, &selch2, &ch2val, &selch3, &ch3val, &selch4, &ch4val);
 381   2          PCT_AudioGainCtrl(0, selch0, ch0val);
 382   2          PCT_AudioGainCtrl(0, selch1, ch1val);
 383   2          PCT_AudioGainCtrl(0, selch2, ch2val);
 384   2          PCT_AudioGainCtrl(0, selch3, ch3val);
 385   2          PCT_AudioGainCtrl(0, selch4, ch4val);
 386   2          break;
 387   2        
 388   2        default:
 389   2          break;
 390   2        }
 391   1      }
 392          
 393          // ***************************************************************************
 394          //
 395          // Monitor Select Live or Mixing Mode 
 396          // alive chan (chan=0xFF is Mixing Mode)
 397          //
 398          void MoniAudioLive(PCHAR szParam)
 399          {
 400   1        data U8 chan;
 401   1      
 402   1        sscanf(szParam, "%bd ", &chan);
 403   1      
 404   1        PCT_AudioSelLive(0,chan);
 405   1      }
 406          
 407          // ***************************************************************************
 408          //
 409          // TW2835 Register All Dump
 410          //
 411          void MoniRegisterDump(void)
 412          {
 413   1        data U8 addr,page;
 414   1        
 415   1      
 416   1        for(page=0;page<3;page++) {
 417   2          printf("\n ======== PAGE %b2x =============\n",page);
 418   2          addr = 0;
 419   2          do {
 420   3            printf("%b2x\t", TW28_ReadByte(page, addr));
 421   3            addr++;
 422   3            if((addr%16)==0)  printf("\n"); 
 423   3          } while( addr );
 424   2        }
 425   1      }
 426          
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/13/2021 11:06:05 PAGE 8   

 427          // ***************************************************************************
 428          //
 429          // video signal mixing to windows
 430          //
 431          void MoniVideoMixWin(PCHAR szParam)
 432          {
 433   1        data U8 chose,wintp;
 434   1      
 435   1        sscanf(szParam, "%1bx %1bx ch%1bx ch%1bx ch%1bx ch%1bx ",
 436   1                &chose, &wintp, &WINCH[0], &WINCH[1], &WINCH[2], &WINCH[3]);
 437   1        chose = (chose<<4)+(wintp&0x0F);
 438   1        PCT_SetXVideoMixing(chose, WINCH);  
 439   1      }
 440          
 441          // ***************************************************************************
 442          //
 443          // setting windows attribute
 444          //
 445          void MoniVideoMixAttr(PCHAR szParam)
 446          {
 447   1        data U16 chose;
 448   1        data U8 attrsel,setval;
 449   1        data U8   winNm[4],wincnt=0;
 450   1        data U8   division;
 451   1        char *getStr;
 452   1      
 453   1        PCT_GetFirstStr(&getStr,&szParam);
 454   1        division = atoi(getStr); 
 455   1      
 456   1        PCT_GetFirstStr(&getStr,&szParam);
 457   1        chose = PCT_StrToCommCode(getStr); 
 458   1      
 459   1        if( chose==PCT_StrToCommCode("enrecall") ) {
 460   2          attrsel = WIN_RECALL_EN;
 461   2          setval  = ON;
 462   2        } else if ( chose==PCT_StrToCommCode("enfreeze") ) {
 463   2          attrsel = WIN_FREEZE;
 464   2          setval  = ON;
 465   2        } else if ( chose==PCT_StrToCommCode("enhmirror") ) {
 466   2          attrsel = WIN_HMIRROR;
 467   2          setval  = ON;
 468   2        } else if ( chose==PCT_StrToCommCode("envmirror") ) {
 469   2          attrsel = WIN_VMIRROR;
 470   2          setval  = ON;
 471   2        } else if ( chose==PCT_StrToCommCode("enenhance") ) {
 472   2          attrsel = WIN_ENHANCE;
 473   2          setval  = ON;
 474   2        } else if ( chose==PCT_StrToCommCode("enblank") ) {
 475   2          attrsel = WIN_BLANK;
 476   2          setval  = ON;
 477   2        } else if ( chose==PCT_StrToCommCode("enbound") ) {
 478   2          attrsel = WIN_BOUND;
 479   2          setval  = ON;
 480   2        } else if ( chose==PCT_StrToCommCode("enblink") ) {
 481   2          attrsel = WIN_BLINK;
 482   2          setval  = ON;
 483   2        } else if ( chose==PCT_StrToCommCode("disrecall") ) {
 484   2          attrsel = WIN_RECALL_EN;
 485   2          setval  = OFF;
 486   2        } else if ( chose==PCT_StrToCommCode("disfreeze") ) {
 487   2          attrsel = WIN_FREEZE;
 488   2          setval  = OFF;
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/13/2021 11:06:05 PAGE 9   

 489   2        } else if ( chose==PCT_StrToCommCode("dishmirror") ) {
 490   2          attrsel = WIN_HMIRROR;
 491   2          setval  = OFF;
 492   2        } else if ( chose==PCT_StrToCommCode("disvmirror") ) {
 493   2          attrsel = WIN_VMIRROR;
 494   2          setval  = OFF;
 495   2        } else if ( chose==PCT_StrToCommCode("disenhance") ) {
 496   2          attrsel = WIN_ENHANCE;
 497   2          setval  = OFF;
 498   2        } else if ( chose==PCT_StrToCommCode("disblank") ) {
 499   2          attrsel = WIN_BLANK;
 500   2          setval  = OFF;
 501   2        } else if ( chose==PCT_StrToCommCode("disbound") ) {
 502   2          attrsel = WIN_BOUND;
 503   2          setval  = OFF;
 504   2        } else if ( chose==PCT_StrToCommCode("disblink") ) {
 505   2          attrsel = WIN_BLINK;
 506   2          setval  = OFF;
 507   2        } else {
 508   2          return;
 509   2        }
 510   1      
 511   1        while( PCT_GetFirstStr(&getStr,&szParam) ) {
 512   2          if(*getStr=='w' && *(getStr+1)=='i' && *(getStr+2)=='n') 
 513   2          {
 514   3            winNm[wincnt] = atoi(getStr+3);
 515   3            wincnt++;
 516   3          }
 517   2        }
 518   1        for( ; wincnt!=0; wincnt--) {
 519   2          if( winNm[wincnt-1]<division ) {
 520   3            PCT_WinAttrCtrl(winNm[wincnt-1], attrsel, setval);
 521   3          }
 522   2        }
 523   1      }
 524          
 525          // ***************************************************************************
 526          //
 527          // Monitor Video Y Channel Select Live or Mixing Mode 
 528          // yvmix chan (chan=0x04 is Mixing Mode)
 529          //
 530          void MoniYVideoMix(PCHAR szParam)
 531          {
 532   1        data U8 chan;
 533   1      
 534   1        sscanf(szParam, "%bd ", &chan);
 535   1        PCT_SetYVideoMixing(chan);
 536   1      }
 537          
 538          // ***************************************************************************
 539          //
 540          // Monitor Video Auto Detect Format 
 541          //
 542          void MoniVideoAutoDetect(void)
 543          {
 544   1        printf("===== Format : ch0=[%bx] ch1=[%bx] ch2=[%bx] ch3=[%bx] =====\n",  \ 
 545   1            PCT_DetectVideoFormat(0x00), \
 546   1            PCT_DetectVideoFormat(0x01), \
 547   1            PCT_DetectVideoFormat(0x02), \
 548   1            PCT_DetectVideoFormat(0x03) \
 549   1        );
 550   1      }
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/13/2021 11:06:05 PAGE 10  

 551          
 552          // ***************************************************************************
 553          //
 554          // Monitor Setting Video Format 
 555          //
 556          void MoniSetVideoFormat(PCHAR szParam)
 557          {
 558   1        data U8 selch0,selch1,selch2,selch3;  
 559   1        data U8 valch0,valch1,valch2,valch3;  
 560   1        char *getStr;
 561   1      
 562   1        PCT_GetFirstStr(&getStr,&szParam);
 563   1      
 564   1        switch( atoi(getStr) ) {
 565   2        case 1:
 566   2          sscanf(szParam,"ch%bd:%bd ",&selch0,&valch0);
 567   2          PCT_SetVideoFormat(0, selch0, valch0<<4);
 568   2          break;
 569   2        
 570   2        case 2:
 571   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ", \
 572   2            &selch0, &valch0, &selch1, &valch1);
 573   2          PCT_SetVideoFormat(0, selch0, valch0<<4);
 574   2          PCT_SetVideoFormat(0, selch1, valch1<<4);
 575   2          break;
 576   2        
 577   2        case 3:
 578   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 579   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2);
 580   2          PCT_SetVideoFormat(0, selch0, valch0<<4);
 581   2          PCT_SetVideoFormat(0, selch1, valch1<<4);
 582   2          PCT_SetVideoFormat(0, selch2, valch2<<4);
 583   2          break;
 584   2        
 585   2        case 4:
 586   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 587   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2, &selch3, &valch3);
 588   2          PCT_SetVideoFormat(0, selch0, valch0<<4);
 589   2          PCT_SetVideoFormat(0, selch1, valch1<<4);
 590   2          PCT_SetVideoFormat(0, selch2, valch2<<4);
 591   2          PCT_SetVideoFormat(0, selch3, valch3<<4);
 592   2          break;
 593   2      
 594   2        default:
 595   2          break;
 596   2        }
 597   1      }
 598          
 599          // ***************************************************************************
 600          //
 601          // Monitor Setting Video Format 
 602          //
 603          void MoniShowSODStr(PCHAR szParam)
 604          {
 605   1        data U8 addrx,addry;
 606   1        char *getStr;
 607   1        
 608   1        PCT_GetFirstStr(&getStr,&szParam);
 609   1        addrx=atoi(getStr);
 610   1        PCT_GetFirstStr(&getStr,&szParam);
 611   1        addry=atoi(getStr);
 612   1      
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/13/2021 11:06:05 PAGE 11  

 613   1        PCT_PreSetForegroundColor(OSD_COL_100WHT);
 614   1        PCT_PreSetBackgroundColor(OSD_COL_BLU);
 615   1        PCT_SetOSDDrawPage(WRPHX_PAGE5);
 616   1        PCT_ShowOSDString(PTH_X, addrx, addry, szParam);
 617   1        PCT_EnShowOSDPage(WRPHX_PAGE5);
 618   1      }
 619          
 620          // ***************************************************************************
 621          //
 622          // Audio Control for HiSarp
 623          //
 624          void PCT_AudioActionForHS(void)
 625          {
 626   1        data U8 winid;
 627   1        data U8 muteFlage=true;
 628   1      
 629   1        // ------------- Control Audio ------------
 630   1        for(winid=0; winid<4; winid++) {
 631   2          if(SYSWINATTR[winid]&BIT4) {
 632   3            PCT_AudioSelLive(0,WINCH[winid]);
 633   3            muteFlage = false;
 634   3          }
 635   2        }
 636   1      
 637   1        if(muteFlage) {
 638   2          // Audio Mute
 639   2          PCT_AudioMixMute(0, ADO_MIX_MUTE_AIN0+ \
 640   2                    ADO_MIX_MUTE_AIN1+ \
 641   2                    ADO_MIX_MUTE_AIN2+ \
 642   2                    ADO_MIX_MUTE_AIN3+ \
 643   2                    ADO_MIX_MUTE_PBAI, OFF);
 644   2          PCT_AudioSelLive(0, 0xFF);
 645   2        }
 646   1        // ----------------------------------------
 647   1      }
 648          
 649          // ***************************************************************************
 650          //
 651          // Command Shell for HiSarp
 652          //
 653          BYTE xdata Original_selwintype = 0;//Kane @HS 2007 0724 Ver3.4
 654          void MoniHSComm(PCHAR szParam) {
 655   1        data U8 winid;
 656   1        data U8 chose,wintp;
 657   1        
 658   1        sscanf(szParam, "%bx %bx ch%bx:%bx ch%bx:%bx ch%bx:%bx ch%bx:%bx ",
 659   1                &chose, &wintp, &WINCH[0], &SYSWINATTR[0], &WINCH[1], &SYSWINATTR[1], &WINCH[2], &SYSWINATTR[2], &WIN
             -CH[3], &SYSWINATTR[3]);
 660   1      
 661   1        selwintype = (SYSTYPE<<7)+(chose<<4)+(wintp&0x0F);
 662   1      
 663   1        // ----------- Y Chanle setting windows horizontal mirror ----------
 664   1          
 665   1        SYSCHATTR[WINCH[0]]=SYSWINATTR[0];
 666   1        SYSCHATTR[WINCH[1]]=SYSWINATTR[1];
 667   1        SYSCHATTR[WINCH[2]]=SYSWINATTR[2];
 668   1        SYSCHATTR[WINCH[3]]=SYSWINATTR[3];
 669   1      
 670   1        PCT_WinAttrCtrlY(0, WIN_HMIRROR, SYSCHATTR[0]&BIT0);  
 671   1        PCT_WinAttrCtrlY(1, WIN_HMIRROR, SYSCHATTR[1]&BIT0);  
 672   1        PCT_WinAttrCtrlY(2, WIN_HMIRROR, SYSCHATTR[2]&BIT0);  
 673   1        PCT_WinAttrCtrlY(3, WIN_HMIRROR, SYSCHATTR[3]&BIT0);  
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/13/2021 11:06:05 PAGE 12  

 674   1        // -----------------------------------------------------------------
 675   1      
 676   1        // ------------- Control Video ------------
 677   1        //if(Original_selwintype != selwintype)//Kane @HS 2007 0724 Ver3.4
 678   1        PCT_RecompenseYHdelay(SYSCHATTR);
 679   1        PCT_SetVideoHDelay(selwintype, WINCH, SYSWINATTR);
 680   1        
 681   1        PCT_SetXVideoMixing(selwintype, WINCH);
 682   1        //PCT_VideoLastModify();
 683   1        for(winid=0; winid<4; winid++) 
 684   1          PCT_WinAttrCtrl(winid, WIN_HMIRROR, SYSWINATTR[winid]&BIT0);
 685   1        // ----------------------------------------
 686   1      
 687   1        // ------------- Control OSD ------------
 688   1        DisUserTimer(USERTMID0);    // Disable real-time detect VLoss
 689   1        EnUserTimer(USERTMID1,5);   // Enable OSD Delay Timer
 690   1        PCT_FlashOSDCtrl(ON);
 691   1        PCT_CheckVMixType(selwintype);
 692   1        PCT_DisShowOSDPage(DISOSD_PHX);
 693   1        PCT_ClearOSDPageX(WRPHX_PAGE0);
 694   1        PCT_ShowModeIcon();
 695   1        PCT_OSD_ActionPthX(SYSWINATTR);
 696   1        Original_selwintype = selwintype;//Kane @HS 2007 0724 Ver3.4
 697   1        // --------------------------------------
 698   1      }
 699          
 700          // ***************************************************************************
 701          //
 702          // Real Time Check System Type PAL or NTSC
 703          //
 704          bit PCT_CheckSystem(void)
 705          {
 706   1        //Kane add>>>>
 707   1        char TempSystem;
 708   1        TempSystem = PCT_DetectVideoFormat(SENSORCHANNEL);
 709   1        //if(SYSTYPE == PCT_DetectVideoFormat(SENSORCHANNEL)) return true;//Kane canceled
 710   1        if(TempSystem == NONE_SYSTEM)
 711   1          return FALSE;
 712   1        if(TempSystem == SYSTYPE)
 713   1          return TRUE;
 714   1      
 715   1        SYSTYPE = TempSystem;
 716   1        //Kane Add<<<<
 717   1        //SYSTYPE = PCT_DetectVideoFormat(SENSORCHANNEL);//Kane canceled
 718   1        SYSMIXTYP = (SYSTYPE<<7)|(SYSMIXTYP&0x7F);
 719   1      
 720   1        PCT_EnShowOSDPage(WRPHX_PAGE1);
 721   1        // ------------- Control Video ------------
 722   1        PCT_ChangeSystemType(SYSTYPE);
 723   1        PCT_RecompenseYHdelay(SYSCHATTR); // preset Y Recompense
 724   1        PCT_SetVideoHDelay(RECWINTYPE, WINCH, SYSWINATTR);
 725   1        
 726   1        PCT_SetXVideoMixing(RECWINTYPE, WINCH);
 727   1        //PCT_VideoLastModify();
 728   1        // ------------- Control OSD ------------
 729   1        PCT_ClearOSDPageX(WRPHX_PAGE0);
 730   1        PCT_ShowModeIcon();
 731   1        PCT_OSD_ActionPthX(SYSWINATTR);
 732   1        PCT_OSDActionForHS();
 733   1        // --------------------------------------
 734   1        return TRUE;  //Pinchi 20150323 add for compiler warning
 735   1      }
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/13/2021 11:06:05 PAGE 13  

 736          
 737          // ***************************************************************************
 738          //
 739          // Command Shell for HiSarp Setting S or J Mode
 740          //
 741          void MoniHSCommSJmode(PCHAR szParam)
 742          {
 743   1        sscanf(szParam, "%bd ", &SYSMODE);
 744   1      }
 745          
 746          // ***************************************************************************
 747          //
 748          // Command Shell for HiSarp Setting S or J Mode
 749          //
 750          void MoniHSCommDisScroll(void)
 751          {
 752   1        PCT_EnShowOSDPage(WRPHX_PAGE1);
 753   1      }
 754          
 755          // ***************************************************************************
 756          //
 757          // Command Shell for HiSarp Setting S or J Mode
 758          //
 759          #if 1  //Pinchi 20150415 add
 760          void MoniHSCommVersion(void)
 761          {
 762   1        U8 version=0;
 763   1      
 764   1      #if (TW2835_MCU == TW8816_MODEL_MEGAWIN)  //Pinchi 20150415 add
 765   1        RS_tx('M');
 766   1      #else
                RS_tx('W');
              #endif
 769   1        //RS_tx(VERSION[0]-'0');
 770   1        //version = (VERSION[1]-'0')*10 + (VERSION[2]-'0');
 771   1        //RS_tx(version);
 772   1        RS_tx(VERSION[0]);
 773   1        RS_tx(VERSION[1]);
 774   1        RS_tx(VERSION[2]);
 775   1        RS_tx(VIDEO_SYS);//ryan@20180417
 776   1      
 777   1        if(TW2837IDCheck==TRUE)
 778   1        {
 779   2          RS_tx('3');
 780   2          RS_tx('7');
 781   2        }
 782   1        else
 783   1          {
 784   2          RS_tx('3');
 785   2          RS_tx('5');
 786   2          }
 787   1        
 788   1      }
 789          #else
              void MoniHSCommVersion(void)
              {
                RS_tx(VERSION[0]);
                RS_tx(VERSION[1]);
              }
              #endif
 796          
 797          // ***************************************************************************
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/13/2021 11:06:05 PAGE 14  

 798          //
 799          // Runing Command Shell
 800          //
 801          
 802          U8 PCT_RunCommShell(char *strptr)
 803          {
 804   1        data U16 commcode;
 805   1        char *getStr;
 806   1          
 807   1        // ---------- Run Command Shell Entry ----------
 808   1        //Kane @HS 2007 0809 Ver3.5>>>>
 809   1        PCT_GetFirstStr(&getStr, &strptr);
 810   1        //getStr=strptr+4;
 811   1        //Kane @HS 2007 0809 Ver3.5<<<<
 812   1        commcode = PCT_StrToCommCode(getStr); 
 813   1        
 814   1        if (commcode == PCT_StrToCommCode("&")) {
 815   2          //printf("Read Page Buffer Data");
 816   2          MoniReadPageBuffer(strptr);
 817   2        }else if( commcode == PCT_StrToCommCode("(")) {
 818   2          //printf("Read One Buffer Data");
 819   2          MoniReadOneBuffer(strptr);
 820   2        }else if( commcode == PCT_StrToCommCode(")")) {
 821   2          //printf("Write One Buffer Data");
 822   2          MoniWriteOneBuffer(strptr);
 823   2        }else if( commcode == PCT_StrToCommCode("busw")) {
 824   2          // ===== ASICBUS Write Byte ======
 825   2          //printf("Command is Write Bus");
 826   2          MoniWriteAsicByte(strptr);
 827   2        } else if (commcode == PCT_StrToCommCode("busr")) {
 828   2          // ===== ASICBUS Read Byte =======
 829   2          //printf("Command is Read Bus");
 830   2          MoniReadAsicByte(strptr);
 831   2        } else if (commcode == PCT_StrToCommCode("amix")) {
 832   2          // ===== Audio mix =======
 833   2          //printf("Command is Audio Mixing");
 834   2          MoniAudioMixing(strptr);
 835   2        } else if (commcode == PCT_StrToCommCode("amute")) {
 836   2          // ===== Audio Mute =======
 837   2          //printf("Command is Audio Mute");
 838   2          MoniAudioMute();
 839   2        } else if (commcode == PCT_StrToCommCode("adump")) {
 840   2          // ===== List Audio Register Value =======
 841   2          //printf("List Audio Register Value");
 842   2          PCT_AudioRegList();
 843   2        } else if (commcode == PCT_StrToCommCode("again")) {
 844   2          // ===== Audio Gain Control =======
 845   2          //printf("Audio Gain Control");
 846   2          MoniAudioGain(strptr);
 847   2        } else if (commcode == PCT_StrToCommCode("alive")) {
 848   2          // ===== Audio Select Live & Mixing Mode =======
 849   2          //printf("Audio Select Live & Mixing Mode");
 850   2          MoniAudioLive(strptr);
 851   2        } else if (commcode == PCT_StrToCommCode("busrt")) {
 852   2          // ===== All Register Dump =======
 853   2          //printf("All Register Dump");
 854   2          MoniRegisterDump();
 855   2        } else if (commcode == PCT_StrToCommCode("vmix")) {
 856   2          // ===== Video Mix's Windows Type Select =======
 857   2          //printf("Video Mix's Windows Type Select");
 858   2          PCT_WinAttrClear(WIN_FREEZE);
 859   2          MoniVideoMixWin(strptr);
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/13/2021 11:06:05 PAGE 15  

 860   2          PCT_SendACK();
 861   2        } else if (commcode == PCT_StrToCommCode("vmixerr")) {
 862   2          // ===== Video Mix's Windows Type Select =======
 863   2          //printf("Video Mixerr's Windows Type Select");
 864   2          MoniVideoMixWin(strptr); 
 865   2        } else if (commcode == PCT_StrToCommCode("vattr")) {
 866   2          // ===== Video Mixing Control =======
 867   2          //printf("Video Attribute Control");
 868   2          MoniVideoMixAttr(strptr);
 869   2        } else if (commcode == PCT_StrToCommCode("yvmix")) {    // HiSharp has used
 870   2          // ===== Video Mixing Control =======
 871   2          PCT_SendACK();
 872   2          //printf("Video Attribute Control");
 873   2          MoniYVideoMix(strptr);
 874   2        } else if (commcode == PCT_StrToCommCode("init")) {
 875   2          // ===== TW2835 initial =======
 876   2          //printf("Initial TW2835");
 877   2          PCT_InitialTW2835();
 878   2        } else if (commcode == PCT_StrToCommCode("vdet")) {
 879   2          // ===== Video Mixing Control =======
 880   2          //printf("Auto Detectation Video Format");
 881   2          MoniVideoAutoDetect();
 882   2        } else if (commcode == PCT_StrToCommCode("vsetf")) {
 883   2          // ===== Video Mixing Control =======
 884   2          //printf("Setting Video Format Control");
 885   2          MoniSetVideoFormat(strptr);
 886   2        } else if (commcode == PCT_StrToCommCode("sstr")) {
 887   2          // ===== Show String on OSD =======
 888   2          //printf("Show String on OSD");
 889   2          MoniShowSODStr(strptr);
 890   2      // --------------------------------------------------------------------------------
 891   2        } else if (commcode == PCT_StrToCommCode("hscom")) {    // HiSharp has used
 892   2          PCT_SendACK();
 893   2          //printf("Command Shell for HiSharp");
 894   2          MoniHSComm(strptr);
 895   2      
 896   2          PCT_AudioActionForHS();
 897   2          PCT_OSDActionForHS();
 898   2          PCT_FlashOSDCtrl(OFF);
 899   2          
 900   2        //  VlossFlag = 0;  //ryan@20150318
 901   2        #ifdef AWT_NO_SIGNAL_MSG  //Pinchi 20150326 add
 902   2          DisUserTimer(USERTMID1);
 903   2          EnUserTimer(USERTMID0,5); 
 904   2      
 905   2        #endif
 906   2        } else if (commcode == PCT_StrToCommCode("mode")) {     // HiSharp has used
 907   2          PCT_SendACK();
 908   2          //printf("Command Shell for HiSharp Set S or J Mode");
 909   2          MoniHSCommSJmode(strptr);
 910   2        } else if (commcode == PCT_StrToCommCode("disscroll")) {  // HiSharp has used
 911   2          PCT_SendACK();
 912   2          //printf("Command Shell for HiSharp Disable Scroll!");
 913   2          MoniHSCommDisScroll();
 914   2        } else if (commcode == PCT_StrToCommCode("ver")) {  // HiSharp has used
 915   2          PCT_SendACK();
 916   2          //printf("Command Shell for HiSharp Disable Scroll!");
 917   2          MoniHSCommVersion();
 918   2          //PCT_InitialTW2835();//Kane @HS 2007 0723 Ver3.4
 919   2      // --------------------------------------------------------------------------------
 920   2        } else {
 921   2        }
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/13/2021 11:06:05 PAGE 16  

 922   1      
 923   1        // ---------------------------------------------
 924   1        return true;
 925   1      }
 926          
 927          
 928          // ===========================================================================
 929          // END of File 
 930          // ===========================================================================
 931          
 932          
 933          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4209    ----
   CONSTANT SIZE    =    735    ----
   XDATA SIZE       =      1    ----
   PDATA SIZE       =     25      46
   DATA SIZE        =   ----      72
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
